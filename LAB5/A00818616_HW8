--1
invert:: [t] -> [t]
invert [] = []
invert [x] = [x]
invert (x:y) = invert y ++ [x]

--2
evaluate:: [Float] -> Float -> Float
evaluate [] _ = 0
evaluate (x:y) num =  x*(num^(length y)) + evaluate y num

--3
cleanString:: [Char] -> [Char]
cleanString [] = ""
cleanString [x] = [x]
cleanString (x:y) = 
  let (a:b) = y in
    if a == x
      then cleanString y
      else x:cleanString y

--4
multiples:: [Int] -> Int -> [Int]
multiples [] _ = []
multiples (x:y) num = 
  if (mod x num) == 0
    then x:multiples y num
    else  multiples y num

--5
toBinaryString:: Int -> [Char]
toBinaryString 0 = "0"
toBinaryString x =
  if x == 1
    then "1"
    else if (mod x 2) == 1
      then toBinaryString (quot x 2)++"1"
      else toBinaryString (quot x 2)++"0"

--6
insert:: [Int] -> Int -> [Int]
insert [] n = []++[n]
insert (x:y) n =
  if x < n
    then [x]++insert y n
    else [n]++[x]++y

insertAux:: [Int] -> Int -> [Int] -> [Int]
insertAux x num [] = insert x num
insertAux x num (a:b) = insertAux (insert x num) a b

insertionSort:: [Int] -> [Int]
insertionSort [] = []
insertionSort [x] = [x]
insertionSort (x:y) =
  let (a:b) = y in
    insertAux [x] a b